% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stan_jm.R
\name{stan_jm}
\alias{stan_jm}
\title{Bayesian joint longitudinal and time-to-event models via Stan}
\usage{
stan_jm(formulaLong, dataLong, formulaEvent, dataEvent, time_var, id_var,
  family = gaussian, assoc_type = assoc(), base_haz = "weibull",
  quadnodes = 15, subsetLong, subsetEvent,
  na.action = getOption("na.action", "na.omit"), weights, offset, contrasts,
  centreLong = FALSE, centreEvent = FALSE, init = "model_based", ...,
  priorLong = normal(), priorLong_intercept = normal(),
  priorLong_ops = priorLong_options(), priorEvent = normal(),
  priorEvent_intercept = normal(), priorEvent_ops = priorEvent_options(),
  priorAssoc = normal(), priorAssoc_ops = priorAssoc_options(),
  prior_covariance = decov(), prior_PD = FALSE, algorithm = c("sampling",
  "meanfield", "fullrank"), adapt_delta = 0.65, QR = FALSE)
}
\arguments{
\item{formulaLong}{A two-sided linear formula object describing both the 
fixed-effects and random-effects parts of the longitudinal submodel  
(see \code{\link[lme4]{glmer}} for details). For a multivariate joint 
model this should be a list of such formula objects, with each element
of the list providing the formula for one of the longitudinal submodels.}

\item{dataLong}{A data frame containing the variables specified in
\code{formulaLong}. If fitting a multivariate joint model, then this can
be either a single data frame which contains the data/variables for all 
the longitudinal submodels, or it can be a list of data frames where each
element of the list provides the data for one of the longitudinal 
submodels.}

\item{formulaEvent}{A two-sided formula object describing the time-to-event
submodel. The left hand side of the formula should be a \code{Surv()} 
object. See \code{\link[survival]{Surv}}.}

\item{dataEvent}{A data frame containing the variables specified in
\code{formulaEvent}.}

\item{time_var}{A character string identifying the name of the variable 
in \code{dataLong} which represents time.}

\item{family}{The family (and possibly also the link function) for the 
longitudinal submodel. See \code{\link[lme4]{glmer}} for details.}

\item{assoc_type}{A list containing elements which are used to construct 
the association structure for the joint model. The appropriate
list can be easily returned via the \code{assoc()} function. See
\code{\link{assoc}} for details on how to specify the arguments correctly.
Alternatively, \code{assoc_type} can be set equal to \code{NULL} for 
fitting a joint model with no association structure (equivalent to 
fitting separate longitudinal and time-to-event models).}

\item{base_haz}{A character string indicating which baseline hazard to use
for the time-to-event submodel. Currently the only option allowed is 
\code{"weibull"} (the default).}

\item{quadnodes}{A numeric scalar giving the number of nodes to use for 
the Gauss-Kronrod quadrature. The quadrature is used to approximate the 
integral over the cumulative hazard in the likelihood function. Options 
are 7, 11 and 15 (the default).}

\item{subsetLong, subsetEvent}{Same as subset in \code{\link[stats]{glm}}.
However, if fitting a multivariate joint model and a list of data frames 
is provided in \code{dataLong} then a corresponding list of subsets 
must be provided in \code{subsetLong}.}

\item{na.action, contrasts}{Same as \code{\link[stats]{glm}}, but rarely 
specified.}

\item{weights, offset}{Same as \code{\link[stats]{glm}}. Not currently 
allowed.}

\item{centreLong, centreEvent}{A logical specifying whether the predictor
matrix for the longitudinal submodel(s) or event submodel should be 
centred.}

\item{init}{The method for generating the initial values for the MCMC.
The default is \code{"model_based"}, which uses initial values obtained 
from fitting separate longitudinal and time-to-event models prior to 
fitting the joint model. Other possibilities for specifying \code{init}
are those described for \code{\link[rstan]{stan}}.}

\item{...}{Further arguments passed to 
\code{\link[rstan]{sampling}} (e.g. \code{iter}, \code{chains}, 
\code{cores}, etc.) or to \code{\link[rstan]{vb}} (if \code{algorithm} is 
\code{"meanfield"} or \code{"fullrank"}).}

\item{priorLong, priorEvent, priorAssoc}{The prior distributions for the 
regression coefficients in the longitudinal submodel(s), event submodel,
and the association parameter(s). 
Can be a call to \code{normal}, \code{student_t},
\code{cauchy}, \code{hs} or \code{hs_plus}. See \code{\link{priors}} for
details. To to omit a prior ---i.e., to use a flat (improper) uniform
prior--- set equal to \code{NULL}.}

\item{priorLong_intercept, priorEvent_intercept}{The prior distributions
for the intercepts in the longitudinal submodel(s) and event submodel.
Can be a call to \code{normal}, \code{student_t} or
\code{cauchy}. See \code{\link{priors}} for details. To to omit a prior
---i.e., to use a flat (improper) uniform prior--- set
equal to \code{NULL}. (\strong{Note:} If \code{centreLong} or 
\code{centreEvent} is set to \code{TRUE} then the prior
distribution for the intercept is set so it applies to the value when all
predictors are centered.)}

\item{priorLong_ops}{Additional options related to prior distributions for
the longitudinal submodel(s). Can  be \code{NULL} to omit a prior on the 
dispersion parameters in the longitudinal submodel(s) and see 
\code{\link{priorLong_options}} otherwise.}

\item{priorEvent_ops}{Additional options related to prior distributions 
for the event submodel. Can be \code{NULL} to omit a prior on the 
Weibull shape parameter (if a Weibull baseline hazard is used) and 
see \code{\link{priorEvent_options}} otherwise.}

\item{priorAssoc_ops}{Additional options related to prior distributions 
for the association parameter(s). See \code{\link{priorAssoc_options}}.}

\item{prior_covariance}{Cannot be \code{NULL}; see \code{\link{decov}} for
more information about the default arguments.}

\item{prior_PD}{A logical scalar (defaulting to \code{FALSE}) indicating
whether to draw from the prior predictive distribution instead of
conditioning on the outcome.}

\item{algorithm}{Character string (possibly abbreviated) indicating the 
estimation approach to use. Only "sampling" (for MCMC) is allowed for 
fitting a model using \code{stan_jm}.}

\item{adapt_delta}{Only relevant if \code{algorithm="sampling"}. See 
\code{\link{adapt_delta}} for details.}

\item{QR}{A logical scalar (defaulting to \code{FALSE}) but if \code{TRUE}
applies a scaled \code{\link{qr}} decomposition to the design matrix, 
\eqn{X = Q^\ast R^\ast}{X = Q* R*}, where 
\eqn{Q^\ast = Q \sqrt{n-1}}{Q* = Q (n-1)^0.5} and
\eqn{R^\ast = \frac{1}{\sqrt{n-1}} R}{R* = (n-1)^(-0.5) R}. The coefficients
relative to \eqn{Q^\ast}{Q*} are obtained and then premultiplied by the
inverse of \eqn{R^{\ast}}{R*} to obtain coefficients relative to the
original predictors, \eqn{X}. These transformations do not change the 
likelihood of the data but are recommended for computational reasons when 
there are multiple predictors. However, because the coefficients relative
to \eqn{Q^\ast}{Q*} are not very interpretable it is hard to specify an 
informative prior. Setting \code{QR=TRUE} is therefore only recommended 
if you do not have an informative prior for the regression coefficients.}
}
\description{
Fits a shared parameter joint model for longitudinal and time-to-event 
(e.g. survival) data under a Bayesian framework using Stan.
}
\details{
The \code{stan_jm} function can be used to fit a joint model (also 
  known as a shared parameter model) for longitudinal and time-to-event data 
  under a Bayesian framework using Stan, but without needing to write the 
  model code or create the data list for Stan. 
  The joint model may be univariate (with only one longitudinal submodel) or
  multivariate (with more than one longitudinal submodel). \cr
  \cr 
  For the longitudinal submodel a generalised linear mixed model is assumed 
  with any of the \code{\link[stats]{family}} choices allowed by 
  \code{\link[lme4]{glmer}} (\strong{Note:} At this stage only gaussian 
  outcomes are currently implemented). For the event submodel a parametric
  proportional hazards model is assumed. Currently only a Weibull baseline 
  hazard is permitted. Time-varying covariates are allowed in both the 
  longitudinal and event submodels. 
  The association structure for the joint model can be based on any of the 
  following parameterisations: current value of the linear predictor in the 
  longitudinal submodel; current expected value in the longitudinal 
  submodel;  
  first derivative (slope) in the longitudinal submodel; first derivative 
  (slope) for the linear predictor in the longitudinal submodel; shared random 
  effects; no association structure (equivalent to fitting separate longitudinal 
  and event models). The association type is most easily specified using the 
  \code{\link{assoc}} function. \cr
  \cr
  Bayesian estimation is performed via MCMC. The Bayesian model includes 
  independent priors on the 
  regression coefficients for both the longitudinal and event submodels, 
  including the association parameter(s) (in much the same way as the
  regression parameters in \code{\link{stan_glm}}) and
  priors on the terms of a decomposition of the covariance matrices of the
  group-specific parameters (in the same way as \code{\link{stan_glmer}}). 
  See \code{\link{priors}} for more information about the priors distributions
  that are available. \cr
  \cr
  Gauss-Kronrod quadrature is used to numerically evaluate the integral  
  over the cumulative hazard in the likelihood function for the joint model.
  The accuracy of the numerical approximation can be controlled using the
  number of quadrature nodes, specified through the \code{quadnodes} 
  argument. Using a higher number of quadrature nodes will result in a more 
  accurate approximation.
}
\examples{
#####
# Univariate joint model, with association structure based on the 
# current value of the linear predictor
f1 <- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              time_var = "year",
              chains = 1, iter = 1000, warmup = 500, refresh = 25)
summary(f1, digits = 3) 
        
#####
# Univariate joint model, with association structure based on the 
# current value of the linear predictor and shared random intercept
f2 <- stan_jm(formulaLong = logBili ~ year + (1 | id), 
              dataLong = pbcLong,
              formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
              dataEvent = pbcSurv,
              assoc_type = assoc("etavalue", shared_b = 1),
              time_var = "year",
              chains = 1, iter = 1000, warmup = 500, refresh = 25)
summary(f2, digits = 3)          

######
# Multivariate joint model, with association structure based 
# on the current value of the linear predictor in each longitudinal 
# submodel and shared random intercept and slope from the second 
# longitudinal submodel (which are the second and third random 
# effects in the joint model, and are therefore indexed by the 
# vector c(2,3) in the code below)
mv1 <- stan_jm(formulaLong = list(
        logBili ~ year + (1 | id), 
        albumin ~ sex + year + (1 +  year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc_type = assoc(list("etavalue", "etavalue")),
        time_var = "year", adapt_delta = 0.75,
        chains = 1, iter = 1000, warmup = 500, refresh = 25)
summary(mv1, digits = 3)              

######
# Multivariate joint model, estimated using multiple MCMC chains 
# run in parallel across all available PC cores
mv2 <- stan_jm(formulaLong = list(
        logBili ~ year + (1 | id), 
        albumin ~ sex + year + (1 +  year | id)),
        dataLong = pbcLong,
        formulaEvent = Surv(futimeYears, death) ~ sex + trt, 
        dataEvent = pbcSurv,
        assoc_type = assoc(list("etavalue", "etavalue")),
        time_var = "year",
        chains = 3, iter = 1000, warmup = 500, refresh = 25,
        cores = parallel::detectCores())
summary(mv2, digits = 3)            

}

